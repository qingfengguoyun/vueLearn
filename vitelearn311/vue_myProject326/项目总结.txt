2024-6-3：
vscode 代码提示快捷键：Ctrl+i

2024-6-4:
1，vue组件，尽可能不在setup中调用异步方法（await的方法），如果一定要调用，
需在onBeforeMounted(async ()=>{})或onMounted(async ()=>{})中使用

2，在hooks中定义的async方法，可以在setup中使用，且无需添加await。将template中
的对象定义在hook中，并通过hook中的方法进行获取与修改是好的实现方式

2024-6-6：
1，pinia的**store.ts文件中，从sessionStorage.getItem()取出来的对象不要取下层数据，
因为可能并不存在，进而导致报错。(sessionStorage.getItem()取出的内容一定需要
JSON.parse()，不要在JSON.parse()后尝试获取下层数据）

2，设置文字自动换行：
/* 自动换行样式 当单词过长时截断单词换行 */
.auto_wrap{
    word-wrap: break-word;
    word-break: break-all;
}
中文通常不会有问题，当英文单词过长时（例如网址链接），将在单词中间进行强制换行

2024-6-12：

1，git 文件默认不区分大小写
通过：git config core.ignorecase进行判断，返回true说明不区分大小写
如果修改文件大小写后需要提交，需进行以下设置：
git config core.ignorecase false

2，git修改小写文件为大写文件的方法：
流程依旧为：“先删除，再添加”
（1）将小写文件的文件名修改为大写并复制到另一位置备份
（2）删除小写文件并git -add -commit -push 提交至远程仓库
（3）把备份的大写文件复制回原位，并git -add -commit -push 提交至远程仓库
相当于提交了一个新文件

**如果直接改名并提交的话，远程仓库将出现两个的文件（仅文件名大小写不同）！！

2024-6-14：

1，watch方法，如果watch的对象被重新赋值导致引用对象变化，watch将失去监视作用
例如监视数组对象array时，若对array采用array=[]的方式清空，则watch的监视将失效
**因此数组清空方法最好使用splice方法：
//  使用splice清空数组的同时，可以保留对原数组的引用
//  api : array.splice(start: number, deleteCount: number, ...items: T[]): T[]
//  start: 表示从哪个索引位置开始操作。
//  deleteCount: 表示要删除多少个元素。如果未设置则默认删除到数组末尾。
//  ...items: 可选，表示要添加到数组中的新元素。

eg: array.splice(0,array.length) 清空array数组


2024-6-20：

1，浏览器vue-devtoll插件不生效解决：
vite.config.ts中添加：__VUE_PROD_DEVTOOLS__:true

eg:
export default defineConfig({
{其他配置}...
  define: {
    __VUE_PROD_DEVTOOLS__:true,
  },
})

2，proxy代理设置

vite.config.ts中
 // proxy:设置代理转发
 // key：匹配请求的路径,正则表达式匹配
 // target: 目标服务器地址和端口号
 // changeOrigin: 代理服务器会更改请求的来源，使其看起来像是直接发送给目标服务器的请求
 // rewrite:(path)=>path.replacce(): 重写路径
 // 实际执行：proxy从上至下依次使用key匹配请求路径，匹配成功后以target替换请求中服务器+端口号的部分
 // 并根据rewrite修改请求路径
eg：
    proxy:{
      '/socket.io': {
        target: IS_DEVELOP?`http://${getNetworkIp()}:${SOCKET_PORT}`:`${REMOTE_BASE_IP}:${SOCKET_PORT}`,
        ws: true,
      },
      '/api':{
        target: IS_DEVELOP?`http://${getNetworkIp()}:${SERVER_PORT}`:`${REMOTE_BASE_IP}:${SERVER_PORT}`,
        changeOrigin:true,
      }
    },
  },


3，线上部署，刷新404问题，nginx反向代理

在nginx.conf中添加配置：
location / { 
  try_files $uri $uri/ /index.html; 
} 

location /api {
  proxy_pass http://{后端服务ip}:{后端服务端口号};
}
//前者表示匹配不到任何界面时重定向至index.html，再通过js进行路由（解决刷新404）
//后者设置反向代理，将路径中包含”/api“的请求转发至指定服务器

**宝塔客户端中，以上配置可以写在”伪静态“配置中，也可以写在配置文件中

4，代理路径拼接规则 

若proxy_pass地址以"/"结尾，即：proxy_pass http://{后端服务ip}:{后端服务端口号}/ ，
表示移除location 匹配到的内容再拼接至地址后

eg：
location  /api{
proxy_pass http://123.56.221.66:8200/
}
则请求 ”/api/get “通过代理转发后变为 http://123.56.221.66/get，/api被移除


2024-06-27

1， <template>标签的特性和作用：
（1）在通常 html 标签中使用：
<template> 标签并不会在最终渲染的 HTML 结构中留下任何痕迹，仅用作模板的占位符。
因为<template> 标签在渲染时并不会生成额外的 DOM 元素，所以适合在v-if，v-for等指令时使用
eg：
<ul>
	<template v-for="(com,index) in comList" :key="index">
	<li>...></li>
	</template>
</ul>

在自定义组件标签中使用：
<template></template>作为插槽使用


2，以string为key值的数组（伪map）

eg： 
interface ComMap{
[key:string]:any
}

通常数组获取值使用下标，eg：array[0]，array[1]
该结构对象获取值使用key值，eg：comMap['key1']，comMap['key2']，获取失败时返回undifined

获取comMap的全部key值组成的数组：Object.keys(comMap)
获取comMap的全部value值组成的数组：Object.values(comMap)

**undifined在作为布尔值时视为false


